---
title: How does AutoPWN Suite work?
date: 2022-06-03 09:00:00
categories: [blog, programming, cyber security,autopwn-suite]
tags: [autopwn-suite]
---

# What is AutoPWN Suite?

[AutoPWN Suite](https://auto.pwnspot.com) is a project for scanning vulnerabilities and exploiting systems automatically.

# Demo

AutoPWN Suite has a very user friendly easy to read output.

<script id="asciicast-497930" src="https://asciinema.org/a/497930.js" async></script>

# How does it work?

AutoPWN Suite uses nmap TCP-SYN scan to enumerate the host and detect the version of softwares running on it. After gathering enough information about the host, AutoPWN Suite automatically generates a list of "keywords" to search [NIST vulnerability database](https://www.nist.gov/).

## Scanning

To create nmap scans in python we use [nmap module](https://bitbucket.org/xael/python-nmap/src/master/) for python.

## Host Discovery

To start doing host discovery, we first have to figure out which scan type we should use. Here's how it's done:

```python
#autopwn.py

if args.scantype == "arp":
    if not is_root():
        print_colored("You must be root to do an arp scan!", colors.red)
        scantype = ScanType.Ping
    else:
        scantype = ScanType.Arp
elif args.scantype == "ping":
    scantype = ScanType.Ping
elif args.scantype == "" or type(args.scantype) == None or args.scantype == None:
    if is_root():
        scantype = ScanType.ARP
    else:
        scantype = ScanType.Ping

```

We now know which scan type to use for host discovery. Let's also get our target to scan.

```python
#autopwn.py

def GetTarget():
    if args.target:
    
        #If the target argument is
        #specified, we just use it.
        
        target = args.target
    else:
        if args.hostfile:
        
            #If hostfile argument is
            #specified instead of target,
            #we get list of,
            #targets to scan from 
            #the host file.

            try:
            
                #Read targets from host
                #file and insert all of
                #them into an array.
                
                target = open(args.hostfile,'r').read().splitlines()
                
            #Handling errors here, 
            #nothing too fancy.
            
            except FileNotFoundError:
                print_colored("Host file not found!", colors.red)
                target = DetectIPRange()
            except PermissionError:
                print_colored("Permission denied while trying to read host file!", colors.red)
                target = DetectIPRange()
            except Exception:
                print_colored("Unknown error while trying to read host file!", colors.red)
                target = DetectIPRange()
        else:
            if DontAskForConfirmation:
            
                #If user specified -y as
                #an argument, we get the
                #range of ip addresses
                #to scan using a custom
                #function, we'll also take
                #a look at that.
                
                target = DetectIPRange()
            else:
            
                #If none of these
                #conditions are true, take
                #the target range from user.
                
                target = input("Enter target range to scan : ")
    return target
```

Here's how we detect target IP address range automatically:

```python
#autopwn.py

def DetectIPRange():
    s = socket(AF_INET, SOCK_DGRAM)
    
    #We connect to google on port 80
    
    s.connect(("8.8.8.8", 80))
    
    #We use getsockname method in our
    #socket to get private IP address

    PrivateIPAdress = s.getsockname()[0]
    
    #Here we split our private IP address
    #into octets from dots and replace last
    #octet with ".0/24"
    
    target = str(str(PrivateIPAdress.split('.')[0]) + '.' + str(PrivateIPAdress.split('.')[1]) + '.' + PrivateIPAdress.split('.')[2] + '.0/24')
    return target
```

Now we know our target and scan type we are going to use. So let's get to scanning!

```python
#modules/scanner.py

def DiscoverHosts(target, scantype=ScanType.ARP, scanspeed=3, mode=ScanMode.Normal):
    print_colored("\n" + "─" * 60, colors.green)
    WriteToFile("\n" + "─" * 60)
    
    #print the total number of the
    #hosts we are scanning if 
    #target variable is a list

    if type(target) is list:
        print_colored(("Scanning " + str(len(target)) + " target(s) using " + str(scantype.name) + " scan...").center(60), colors.green)
        WriteToFile("\nScanning %d hosts using %s scan..." % (len(target), str(scantype.name)))
    else:
        print_colored(("Scanning " + target + " using " + str(scantype.name) + " scan...").center(60), colors.green)
        WriteToFile(("Scanning " + target + " using " + str(scantype.name) + " scan...").center(60))
    
    print_colored("─" * 60 + "\n", colors.green)
    WriteToFile("─" * 60 + "\n")

    if scantype == ScanType.Ping:
        OnlineHosts = TestPing(target, mode)
        return OnlineHosts

    elif scantype == ScanType.ARP:
        OnlineHosts = TestArp(target, mode)
        return OnlineHosts
```

Online hosts in our network is returned from the function.

## Port Scanning

In the previous part we ran a scan in our network to detect hosts that are online. But that information on it's own is not enough. We need to detect the version of softwares running on the target machine. In order to do that, we scan the target machine for open ports.

It's actually pretty straight forward.

```python
#modules/scanner.py

def PortScan(target, scanspeed, mode):

    #Here we just print that
    #we are scanning the host

    print_colored("\n" + "─" * 60, colors.green)
    print_colored(("Running a portscan on host " + str(target) + "...").center(60), colors.green)
    print_colored("─" * 60 + "\n", colors.green)

    WriteToFile("\n" + "─" * 60)
    WriteToFile(("Portscan results for host " + str(target) + ".").center(60))
    WriteToFile("─" * 60 + "\n")

    nm = PortScanner()
    try:
        if is_root():
            if mode == ScanMode.Evade:
                #custom arguments are used if evasion mode is enabled
                resp = nm.scan(hosts=target, arguments="-sS -sV -O -Pn -T 2 -f -g 53 --data-length 10 %s" % (customflags))
            else:
                resp = nm.scan(hosts=target, arguments="-sS -sV --host-timeout 60 -Pn -O -T %d %s" % (scanspeed, customflags))
        else:
            resp = nm.scan(hosts=target, arguments="-sV --host-timeout 60 -Pn -T %d %s" % (scanspeed, customflags))

    except Exception as e:
        print_colored("Error: %s" % (e), colors.red)
        WriteToFile("Error: %s" % (e))
        exit(0)
 
    #We are going to return PortScanner
    #object. This is going to be useful
    #later on.
    
    return nm
```

## Analyzing the Results

We ran a port scan on the host, but we didn't print any information on the screen yet. We are going to use a custom function to analyze results and print them on to screen.

As I documented in the code snippet, we returned a `PortScanner` object as results, let's analyze it.

```python
#modules/scanner.py

def AnalyseScanResults(nm, target=None):
    HostArray = []
  
    #target is the first host from our portscanner object if its not specified.
    if target is None:
        target = nm.all_hosts()[0]
        
    #if we get keyerror here that means our target is not online.
    try:
        nm[target]
    except KeyError:
        print_colored("Target " + str(target) + " seems to be offline.", colors.red)
        WriteToFile("Target " + str(target) + " seems to be offline.")
        return []


    #Assigning variables for target
    #mac, vendor, os, os dettarget
    #accuracy and os type.
    #We try to access the values in our
    #object, if we can't access them we
    #set our variable to unknown.
 
    try:
        mac = nm[target]['addresses']['mac']
    except KeyError:
        mac = 'Unknown'
    except IndexError:
        mac = 'Unknown'

    try:
        vendor = nm[target]['vendor'][mac]
    except KeyError:
        vendor = 'Unknown'
    except IndexError:
        vendor = 'Unknown'

    try:
        os = nm[target]['osmatch'][0]['name']
    except KeyError:
        os = 'Unknown'
    except IndexError:
        os = 'Unknown'

    try:
        accuracy = nm[target]['osmatch'][0]['accuracy']
    except KeyError:
        accuracy = 'Unknown'
    except IndexError:
        accuracy = 'Unknown'

    try:
        ostype = nm[target]['osmatch'][0]['osclass'][0]['type']
    except KeyError:
        ostype = 'Unknown'
    except IndexError:
        ostype = 'Unknown'


    print(
        (
            bcolors.yellow + "MAC Address : " + bcolors.endc + "{0:20}" +
            bcolors.yellow + " Vendor : " + bcolors.endc + "{1:30}"
        ).format(mac , vendor[:30])
    )

    WriteToFile(
        (
            "MAC Address : {0:20}" +
            " Vendor : {1:30}\n"
        ).format(mac, vendor[:30])
    )

    print(
        (
            bcolors.yellow + "OS : " + bcolors.endc + "{0:20}" +
            bcolors.yellow + " Accuracy : " + bcolors.endc + "{1:5}" +
            bcolors.yellow + " Type : " + bcolors.endc + "{2:20}"
        ).format(os[:20], accuracy , ostype[:20])
    )

    WriteToFile(
        (
            "OS : {0:20}" +
            " Accuracy : {1:5}" +
            " Type : {2:20}"
        ).format(os[:20], accuracy , ostype[:20])
    )

    print("\n")
    WriteToFile("\n")
 
    #Here we print "Target seems to 
    #be us" if the reason for status 
    #is "localhost-response" or 
    #"user-set".
        
    if nm[target]['status']['reason'] == 'localhost-response' or nm[target]['status']['reason'] == 'user-set':
        print_colored('Target ' + str(target) + ' seems to be us.', colors.underline)
        WriteToFile('Target ' + str(target) + ' seems to be us.\n')
        
    #If target has no protocols we
    #print "Target seems to have no
    #open ports."
        
    if len(nm[target].all_protocols()) == 0:
        print_colored("Target " + str(target) + " seems to have no open ports.", colors.red)
        WriteToFile("Target " + str(target) + " seems to have no open ports.")
        return HostArray
    for port in nm[target]['tcp'].keys():
                        
        #same here try to assign, if fails assign 'Unknown'
        if not len(nm[str(target)]['tcp'][int(port)]['state']) == 0:
            state = nm[str(target)]['tcp'][int(port)]['state']
        else:
            state = 'Unknown'
    
        if not len(nm[str(target)]['tcp'][int(port)]['name']) == 0:
            service = nm[str(target)]['tcp'][int(port)]['name']
        else:
            service = 'Unknown'

        if not len(nm[str(target)]['tcp'][int(port)]['product']) == 0:
            product = nm[str(target)]['tcp'][int(port)]['product']
        else:
            product = 'Unknown'

        if not len(nm[str(target)]['tcp'][int(port)]['version']) == 0:
            version = nm[str(target)]['tcp'][int(port)]['version']
        else:
            version = 'Unknown'

        print(
            (
                bcolors.cyan + "Port : " + bcolors.endc + "{0:10}" + 
                bcolors.cyan + " State : " + bcolors.endc + "{1:10}" +
                bcolors.cyan + " Service : " + bcolors.endc + "{2:15}" +
                bcolors.cyan + " Product : " + bcolors.endc + "{3:20}" +
                bcolors.cyan + " Version : " + bcolors.endc + "{4:15}"
            ).format(str(port), state, service[:15], product[:20], version[:15])
        )

        WriteToFile(
            (
                "Port : {0:10}" + 
                " State : {1:10}" +
                " Service : {2:20}" +
                " Product : {3:20}" +
                " Version : {4:20}"
            ).format(str(port), state, service[:15], product[:20], version[:15])
        )
        
        #if the port is open, pack it and store it inside the array.
        if state == 'open':
            HostArray.insert(len(HostArray), [target, port, service, product, version])

    return HostArray
```

## Vulnerability detection

We scanned our host and now we now its open ports and some additional information on those ports.

Now this part is where I consider to be the actual magic. This part is essentially what makes vulnerability detection work.

```python
#modules/searchvuln.py

def GenerateKeywords(HostArray):
    keywords = []
    for port in HostArray:
        #Assigning variables.
        target = str(port[0])
        targetport = str(port[1])
        service = str(port[2])
        product = str(port[3])
        version = str(port[4])
        templist = []
        
        #dont search if keyword is equal 
        #to any of these

        dontsearch = ['ssh', 'vnc', 'http', 'https', 'ftp', 'sftp', 'smtp', 'smb', 'smbv2']

        #if any of these equal to 
        #'Unknown' set them to empty string.
 
        if service == 'Unknown':
            service = ''
        
        if product == 'Unknown':
            product = ''
        
        if version == 'Unknown':
            version = ''

        #Append product and version
        #information to temporary 
        #keywords list.
        
        if product.lower() not in dontsearch and not product == '':
            query1 = (product + ' ' + version).rstrip()
            templist.append(query1)

        #Only append unique entries in
        #temporary keywords list into array
        #of keywords we are going to 
        #use for searching vvulnerabilities

        for entry in templist:
            if entry not in keywords and not entry == '':
                keywords.append(entry)

    return keywords
```

We generated our list of keywords, now it's time to turn them into search queries and throw them at the [NIST vulnerability database](https://www.nist.gov/) as a POST request then see what we get.

```python
#modules/searchvuln.py

def SearchSploits(HostArray, apiKey=None):
    VulnsArray = []
    target = str(HostArray[0][0])

    print_colored("\n" + "─" * 60, colors.red)
    print_colored(("Possible vulnerabilities for " + target).center(60), colors.red)
    print_colored("─" * 60 + "\n", colors.red)

    WriteToFile("\n" + "─" * 60)
    WriteToFile(("Possible vulnerabilities for " + target).center(60))
    WriteToFile("─" * 60 + "\n")

    keywords = GenerateKeywords(HostArray)

    #check for the lengt of the keywords.

    if len(keywords) == 0:
        print_colored(("Insufficient information for " + target).center(60), colors.yellow)
        WriteToFile(("Insufficient information for " + target).center(60))
        return

    print("Searching vulnerability database for %s keyword(s)...\n" % (len(keywords)))
    WriteToFile("Searching vulnerability database for %s keyword(s)..." % (len(keywords)))

    for keyword in keywords:
        #https://github.com/vehemont/nvdlib
        #search the NIST vulnerabilities database for the generated keywords
 
        CPETitle, ApiResponseCVE = SearchKeyword(keyword, apiKey)

        #if the keyword is found in the NVD database, print the title of the vulnerable software
        if CPETitle != '':
            Title = CPETitle
        elif CPETitle == '' and len(ApiResponseCVE) != 0:
            Title = keyword
        elif CPETitle == '' and len(ApiResponseCVE) == 0:
            continue

        # create a Vuln object
        # vuln object is just a simple dataclass for a vulnerability.
        VulnObject = Vuln(Software=Title, CVEs=[])

        print("\n\n┌─" + bcolors.yellow + "[ " + Title + " ]" + bcolors.endc)
        WriteToFile("\n\n┌─[ %s ]" % Title)

        for CVE in ApiResponseCVE:
            print("│\n├─────┤ " + bcolors.red + str(CVE.id) + bcolors.endc + "\n│")
            WriteToFile("│\n├─────┤ " + str(CVE.id) + "\n│")

            description = str(CVE.cve.description.description_data[0].value)
            severity = str(CVE.score[2])
            score = str(CVE.score[1])
            details = CVE.url

            try:
                exploitability = str(CVE.v3exploitability)
            except AttributeError:
                try:
                    exploitability = str(CVE.v2exploitability)
                except AttributeError:
                    exploitability = "Could not fetch exploitability score for " + str(CVE.id)

            termsize = get_terminal_size()
            wrapped_description = wrap(description, termsize.columns - 50)

            print("│\t\t" + bcolors.cyan + "Description : " + bcolors.endc)
            WriteToFile("│\t\t" + "Description : ")
            for line in wrapped_description:
                print("│\t\t\t" + line)
                WriteToFile("│\t\t\t" + line)
            print("│\t\t" + bcolors.cyan + "Severity : " + bcolors.endc + severity + " - " + score)
            WriteToFile("│\t\t" + "Severity : " + severity + " - " + score)
            
            print("│\t\t" + bcolors.cyan + "Exploitability : " + bcolors.endc + exploitability)
            WriteToFile("│\t\t" + "Exploitability : " + exploitability)
            
            print("│\t\t" + bcolors.cyan + "Details : " + bcolors.endc + details)
            WriteToFile("│\t\t" + "Details : " + details)

            #append CVEID to out VulnObject for later use.
            VulnObject.CVEs.append(str(CVE.id))

        VulnsArray.append(VulnObject)
        print(" " * 100, end="\r") #clear the line
        print("└" + "─" * 59)

    return VulnsArray
```

## Automatically downloading exploits

We scanned our host and found some vulnerabilities. Now it's time for exploitation! To exploit our target we will need to download "exploit codes".

Here's the structre of what an exploit code will look like in our program.

```python
#modules/getexploits.py 

@dataclass
class ExploitInfo:
    Platform : str
    PublishDate : str
    Type : str
    ExploitDBID : int
    Author : str
    Metasploit : bool
    Verified : bool
    Link : str
```

## Getting our exploits

This part is pretty straight forward. Just passing every "vulnerability" object to our `GetExploitAsFile` function.

```python
#modules/getexploits.py 

def GetExploitsFromArray(VulnsArray, target=None):
    print_colored("\n" + "─" * 60, colors.blue)
    if target:
        print_colored(("Downloading exploits for %s..." % (target)).center(60), colors.blue)
    else:
        print_colored("Downloading exploits...".center(60), colors.blue)
    print_colored("─" * 60, colors.blue)
    WriteToFile("\nDownloading exploits...")

    for vulnerability in VulnsArray:
        GetExploitAsFile(vulnerability)
```

## Getting some info about our exploit

We will gather some information about our exploit to print it onto terminal.

```python
#modules/getexploits.py

def GetExploitAsFile(vulnerability):
    SoftwareName = vulnerability.Software
    CVEs = vulnerability.CVEs

    for CVE in CVEs:
        Exploits = GetExploitInfo(CVE)
        if not len(Exploits) > 0:
            continue

        #only print software name if its not printed before.

        if not SoftwareName in printed_software:
            print("\n\n┌─" + bcolors.yellow + "[ " + SoftwareName + " ]" + bcolors.endc + "\n│")
            printed_software.append(SoftwareName)
            WriteToFile("\n\n┌─[ %s ]" % SoftwareName)

        #print CVEID
        print("│\n├─────┤ " + bcolors.red + str(CVE) + bcolors.endc + "\n│")
        WriteToFile("\n├─────┤ " + CVE + "\n│")

        for exploit in Exploits:

            print(" " * 100, end="\r") #clear the line
            print("Downloading exploit for %s (%s)..." % (SoftwareName, CVE), end="\r")
            
            #function used here just gets the file contents for the exploit
            #no need to show the actual code for as i suppose

            content, filename = GetExploitContents(exploit.Link)
            if content is None:
                continue
            
            #create necessary directories
            if not exists("exploits"):
                mkdir("exploits")
            if not exists("exploits/" + SoftwareName):
                mkdir("exploits/" + SoftwareName)
            if not exists("exploits/" + SoftwareName + "/" + CVE):
                mkdir("exploits/" + SoftwareName + "/" + CVE)

            with open("exploits/" + SoftwareName + "/" + CVE + "/" + filename, "wb") as exploitfile:
                #print some informatio
                print(" " * 100, end="\r") #clear the line
                print("├──────────# exploits/" + SoftwareName + "/" + CVE + "/" + filename + "\n│")
                print("│\t\t" + bcolors.cyan + "Platform: " + bcolors.endc + exploit.Platform)
                print("│\t\t" + bcolors.cyan + "Type: " + bcolors.endc + exploit.Type)
                print("│\t\t" + bcolors.cyan + "Author: " + bcolors.endc + exploit.Author)
                print("│\t\t" + bcolors.cyan + "Date: " + bcolors.endc + exploit.PublishDate)
                print("│\t\t" + bcolors.cyan + "Metasploit: " + bcolors.endc + str(exploit.Metasploit))
                print("│\t\t" + bcolors.cyan + "Verified: " + bcolors.endc + str(exploit.Verified))
                print("│\t\t" + bcolors.cyan + "Link: " + bcolors.endc + exploit.Link + "\n│")
                WriteToFile("├──────────# exploits/" + SoftwareName + "/" + CVE + "/" + filename + "\n│")
                exploitfile.write(content)
                exploitfile.close()
    if SoftwareName in printed_software:
        print(" " * 100, end="\r")
        print("└" + "─" * 59 + "\n")

```


# Noise mode

This mode is for generating a lot of suspicious activity in the network to cause a lot of false positives in IDS/IPS and network logs.

## Creating noisy processes

This part we use multi threading module that is built into python to create separate processes for each host.

```python
#modules/scanner.py

#i dont know why i called this "NoiseScan"
def NoiseScan(target, scantype=ScanType.ARP, timeout=None):
    print_colored("\n" + "─" * 60, colors.green)
    print_colored("Creating noise...".center(60), colors.green)
    print_colored("─" * 60 + "\n", colors.green)
    WriteToFile("\nCreating noise...")

    if scantype == ScanType.Ping:
        Uphosts = TestPing(target)
    elif scantype == ScanType.ARP:
        if is_root():
            Uphosts = TestArp(target)
        else:
            Uphosts = TestPing(target)
    
    NoisyProcesses = []

    #create a noisy process and append it to "NoisyProcesses" list
    for host in Uphosts:
        print_colored("Started creating noise on %s..." % (host), colors.green)
        P = Process(target=CreateNoise, args=(host,))
        NoisyProcesses.append(P)
        P.start()

    try:
        if timeout:
            while True:
                #fancy spinning bar and timeout.
                print("|   " + str(timeout) + " seconds left!", end="     \r")
                sleep(0.25)
                print("/   " + str(timeout) + " seconds left!", end="     \r")
                sleep(0.25)
                print("-   " + str(timeout) + " seconds left!", end="     \r")
                sleep(0.25)
                print("\\   " + str(timeout) + " seconds left!", end="     \r")
                sleep(0.25)
                timeout -= 1
                if timeout == 0:
                    print("\nNoise scan complete!")
                    #terminate noisyprocesses
                    for P in NoisyProcesses:
                        P.terminate()
                    exit(0)
                    break
        else:
            while True:
                sleep(1)
    except KeyboardInterrupt:
        print_colored("\nStopping noise...", colors.red)
        WriteToFile("\nStopped noise...")
        #terminate noisyprocesses
        for P in NoisyProcesses:
            P.terminate()
        exit(0)
```

## Creating the noise

This part is also pretty straight forward. We spawn a nmap process with speed set to 5. 

```python
#modules/scanner.py

def CreateNoise(target):
    nm = PortScanner()
    try:
        if is_root():
            while True:

                #We send 10 more additional
                #packets for each request
                #with random IP addresses
                #to create even more noise.
 
                resp = nm.scan(hosts=target, arguments="-A -T 5 -D RND:10")
        else:
            while True:
                resp = nm.scan(hosts=target, arguments="-A -T 5")
    except KeyboardInterrupt:
        pass
```

# Installation

## You can install it using pip. (sudo recommended)

```
sudo pip install autopwn-suite
```

OR

## You can clone the repo.

```
git clone https://github.com/GamehunterKaan/AutoPWN-Suite.git
```
OR

## You can download debian (deb) package from [releases.](https://github.com/GamehunterKaan/AutoPWN-Suite/releases)

```
sudo apt-get install ./autopwn-suite_1.1.5.deb
```

OR

## You can use Google Cloud Shell.

[![Open in Cloud Shell](https://gstatic.com/cloudssh/images/open-btn.svg)](https://shell.cloud.google.com/cloudshell/editor?cloudshell_git_repo=https://github.com/GamehunterKaan/AutoPWN-Suite.git)


# Usage

Running with root privileges (sudo) is always recommended.

## Automatic mode (This is the intended way of using AutoPWN Suite.)

```console
autopwn-suite -y
```

## Help Menu

```console
$ autopwn-suite -h
usage: autopwn.py [-h] [-o OUTPUT] [-t TARGET] [-hf HOSTFILE] [-st {arp,ping}] [-nf NMAPFLAGS] [-s {0,1,2,3,4,5}] [-a API] [-y] [-m {evade,noise,normal}] [-nt TIMEOUT] [-c CONFIG] [-v]

AutoPWN Suite

options:
  -h, --help            show this help message and exit
  -o OUTPUT, --output OUTPUT
                        Output file name. (Default : autopwn.log)
  -t TARGET, --target TARGET
                        Target range to scan. This argument overwrites the hostfile argument. (192.168.0.1 or 192.168.0.0/24)
  -hf HOSTFILE, --hostfile HOSTFILE
                        File containing a list of hosts to scan.
  -st {arp,ping}, --scantype {arp,ping}
                        Scan type.
  -nf NMAPFLAGS, --nmapflags NMAPFLAGS
                        Custom nmap flags to use for portscan. (Has to be specified like : -nf="-O")
  -s {0,1,2,3,4,5}, --speed {0,1,2,3,4,5}
                        Scan speed. (Default : 3)
  -a API, --api API     Specify API key for vulnerability detection for faster scanning. (Default : None)
  -y, --yesplease       Don't ask for anything. (Full automatic mode)
  -m {evade,noise,normal}, --mode {evade,noise,normal}
                        Scan mode.
  -nt TIMEOUT, --noisetimeout TIMEOUT
                        Noise mode timeout. (Default : None)
  -c CONFIG, --config CONFIG
                        Specify a config file to use. (Default : None)
  -v, --version         Print version and exit.
```

# Contributing to AutoPWN Suite

I would be glad if you are willing to contribute this project. I am looking forward to merge your pull request unless its something that is not needed or just a personal preference. [Click here for more info!](https://github.com/GamehunterKaan/AutoPWN-Suite/blob/main/CONTRIBUTING.md)


# Legal

You may not rent or lease, distribute, modify, sell or transfer the software to a third party. AutoPWN Suite is free for distribution, and modification with the condition that credit is provided to the creator and not used for commercial use. You may not use software for illegal or nefarious purposes. No liability for consequential damages to the maximum extent permitted by all applicable laws.


# Support or Contact

Having trouble using this tool? You can reach me out on [discord](https://search.discordprofile.info/374953845438021635) or [create an issue!](https://github.com/GamehunterKaan/AutoPWN-Suite/issues/new/choose)
